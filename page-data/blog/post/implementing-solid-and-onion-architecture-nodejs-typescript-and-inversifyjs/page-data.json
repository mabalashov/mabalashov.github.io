{"componentChunkName":"component---src-templates-post-template-js","path":"/blog/post/implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs","result":{"data":{"markdownRemark":{"id":"27cbbc0d-5112-5826-b6c1-bca56d82c545","html":"<p>В данной статье мы рассмотрим принципы Onion Architecture. Onion Architecture это методология построения приложений,\nпостроенная на принципах Solid. Она актино использует Инверсию Управления, испытала влияние приципов DDD и немного\nвзяла из функционального программирования.</p>\n<hr>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/01.jpg\" alt=\"Onion Architecture\" title=\"Onion Architecture\">\n<em>Перевод статьи <a href=\"https://dev.to/remojansen/implementing-the-onion-architecture-in-nodejs-with-typescript-and-inversifyjs-10ad\">Implementing SOLID and the onion architecture in Node.js with TypeScript and InversifyJS</a> от <a href=\"http://twitter.com/RemoHJansen\">Remo H. Jansen</a> 10 апреля 2018</em></p>\n<h2 id=\"предпосылка\" style=\"position:relative;\"><a href=\"#%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%81%D1%8B%D0%BB%D0%BA%D0%B0\" aria-label=\"предпосылка permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ПРЕДПОСЫЛКА</h2>\n<p>Следующая часть посвящена некоторым принципам и шаблонам проектирования, в которых нам нужно разобраться, чтобы понять\nOnion Architecture.</p>\n<h1 id=\"the-separation-of-concerns-soc-principle\" style=\"position:relative;\"><a href=\"#the-separation-of-concerns-soc-principle\" aria-label=\"the separation of concerns soc principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8\">THE SEPARATION OF CONCERNS (SOC) PRINCIPLE</a></h1>\n<p><em>Concerns</em> - это различные функциональные части приложения. Например <a href=\"https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0\"><em>бизнес логика</em></a> приложения это <em>concern</em>, и интерфейс, при помощи которого пользователь обращается к <em>этой бизнес</em> логике - тоже <em>concern</em>.</p>\n<p>Благодаря <em>separation of concerns</em>, код этих различных concern’ов находится в различных местах. Изменение интерфейса\nдолжно быть возможно без изменения кода <em>бизнес логики</em>.</p>\n<h1 id=\"the-solid-principles\" style=\"position:relative;\"><a href=\"#the-solid-principles\" aria-label=\"the solid principles permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)\">THE SOLID PRINCIPLES</a></h1>\n<p>SOLID - это акроним для следующих принципов:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/02.png\" alt=\"SOLID\" title=\"SOLID\"></p>\n<h2 id=\"single-responsibility-principle\" style=\"position:relative;\"><a href=\"#single-responsibility-principle\" aria-label=\"single responsibility principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SINGLE RESPONSIBILITY PRINCIPLE</h2>\n<p>Класс должен иметь только одну ответственность</p>\n<p>Самый эффектиный способ испортить приложение - создать <a href=\"https://ru.wikipedia.org/wiki/%D0%91%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82\"><em>God Class</em></a>.</p>\n<p><em>God Class</em> - это класс, который знает или делает слишком много. God Object - яркий пример анти-паттерна</p>\n<p><em>God Class</em> манипулирует большим количеством информации и имеет множество ответственностей. Небольшое изменение кода\nможет затронуть функциональность других частей класса и, как следствие, функциональность других классов, использующих\nданный класс, что приводит к большим проблемам при поддержке кода. Становится проще добавлять новый код, нежели,\nредактировать старый, что в свою очередь приводит к еще большему хаосу.</p>\n<p>В данном примере приведен код класса на Typescript, описывающего персону. Данный класс не должен содержать валидацию\nemail, потому что это не относится к поведению персоны:</p>\n<pre><code class=\"language-typescript\">class Person {\n  public name : string;\n  public surname : string;\n  public email : string;\n \n  constructor(name : string, surname : string, email : string) {\n    this.surname = surname;\n    this.name = name;\n\n    if(this.validateEmail(email)) {\n      this.email = email;\n    } else {\n      throw new Error(\"Invalid email!\");\n    }\n  }\n\n  validateEmail(email : string) {\n    var re = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i;\n   \n    return re.test(email);\n  }\n\n  greet() {\n    alert(\"Hi!\");\n  }\n}\n</code></pre>\n<p>Мы можем отрефакторить этот класс и удалить ответственность за валидацию email из персоны и создать для этого отдельный класс Email:</p>\n<pre><code class=\"language-typescript\">class Email {\n  public email : string;\n\n  constructor(email : string){\n    if(this.validateEmail(email)) {\n      this.email = email;\n    } else {\n      throw new Error(\"Invalid email!\");\n    }\n  }\n\n  validateEmail(email : string) {\n    var re = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i;\n    return re.test(email);\n  }\n}\n\nclass Person {\n  public name : string;\n  public surname : string;\n  public email : Email;\n\n  constructor(name : string, surname : string, email : Email){\n    this.email = email;\n    this.name = name;\n    this.surname = surname;\n  }\n\n  greet() {\n    alert(\"Hi!\");\n  }\n}\n</code></pre>\n<p>Если класс имеет всего одну ответственность, становится гораздо проще понять, что он делает и как можно его расширить\nили улучшить.</p>\n<h2 id=\"openclose-principle\" style=\"position:relative;\"><a href=\"#openclose-principle\" aria-label=\"openclose principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OPEN/CLOSE PRINCIPLE</h2>\n<p>Сущности должны быть открыты для расширения, но закрыты для изменения</p>\n<p>В данном листинге мы видем пример кода, который не следует <em>open/close principle</em>:</p>\n<pre><code class=\"language-typescript\">class Rectangle {\n  public width: number;\n  public height: number;\n}\n\nclass Circle {\n  public radius: number;\n}\n\nfunction getArea(shapes: (Rectangle|Circle)[]) {\n  return shapes.reduce(\n    (previous, current) => {\n      if (current instanceof Rectangle) {\n        return current.width * current.height;\n      } else if (current instanceof Circle) {\n        return current.radius * current.radius * Math.PI;\n      } else {\n        throw new Error(\"Unknown shape!\")\n      }\n    },\n    0\n  );\n}\n</code></pre>\n<p>Данный код позволяет нам вычислить площать двух фигур (Rectangle и Circle). Если мы захотим добавить поддержку другого\nтипа фигур, нам будет необходимо расширить наш код. Мы можем просто добавить поддержку нового типа фигуры (наше\nприложение открыто для расширения), однако, проблема в том, что чтобы это сделать, нам нужно отредактировать функцию\ngetArea, что обозначает, что наше приложение также открыто для модификации.</p>\n<p>Решение данной проблемы в использовании преимуществ полиморфизма, как показано в примере ниже:</p>\n<pre><code class=\"language-typescript\">interface Shape {\n  area(): number;\n}\n\nclass Rectangle implements Shape {\n  public width: number;\n  public height: number;\n\n  public area() {\n    return this.width * this.height;\n  }\n}\n\nclass Circle implements Shape {\n  public radius: number;\n\n  public area() {\n    return this.radius * this.radius * Math.PI;\n  }\n}\n\nfunction getArea(shapes: Shape[]) {\n  return shapes.reduce(\n    (previous, current) => previous + current.area(),\n    0\n  );\n}\n</code></pre>\n<p>Данное решение позволяет нам добавлять новые типы фигур (открыто для расширения) без редактирования существующего кода\n(закрыто для модификации).</p>\n<h2 id=\"liskov-substitution-principle\" style=\"position:relative;\"><a href=\"#liskov-substitution-principle\" aria-label=\"liskov substitution principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LISKOV SUBSTITUTION PRINCIPLE</h2>\n<p>Должна быть возможность заменить любой объект его потомком, не нарушая корректность работы программы.</p>\n<p><em>Liskov substitution principle</em> также предлагает нам использовать преимущества полиморфизма. Например, в данном коде:</p>\n<pre><code class=\"language-typescript\">function getArea(shapes: Shape[]) {\n  return shapes.reduce(\n    (previous, current) => previous + current.area(),\n    0\n  );\n}\n</code></pre>\n<p>Мы использовали интерфейс Shape, чтобы удостовериться, что наша программа открыта для расширения, но закрыта для\nмодификации. <em>Liskov substitution principle</em> обозначает, что мы можем передать любой объект, имплементирующий интерфейс\nShape в функцию getArea и это никак не повлияет на корректность работы программы. В языках со статической типизацией,\nнапример, в Typescript, компилятор проверит за нас корректность имплементации интерфейса (например, если в классе,\nимплементирующем интерфейс Shape будет пропущен метод area, то компиляция завершится с ошибкой). Это обозначает, что\nнам не нужно что-либо проверять вручную, чтобы удостовериться, что приложение следует <em>Liskov substitution principle</em>.</p>\n<h2 id=\"interface-segregation-principle\" style=\"position:relative;\"><a href=\"#interface-segregation-principle\" aria-label=\"interface segregation principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTERFACE SEGREGATION PRINCIPLE</h2>\n<p>Много небольших специфичных интерфейсов лучше, чем один большой общего назначения.</p>\n<p>Interface segregation principle предостерегает нас от нарушения single responsibility principle и separation of\nconcerns principle.</p>\n<p>Давайте представим, что у нас есть две доменные сущности: Rectangle и Circle. Вы использовали эти сущности в ваших\nдоменных сервисах, чтобы посчитать их площадь. Все было прекрасно, но теперь вам необходимо реализовать возможность\nих сериализации в одном из <em>infrastructure layer</em>. Мы можем решить проблему, добавив новый метод в интерфейс Shape:</p>\n<pre><code class=\"language-typescript\">interface Shape {\n  area(): number;\n  serialize(): string;\n}\n\nclass Rectangle implements Shape {\n\n  public width: number;\n  public height: number;\n\n  public area() {\n    return this.width * this.height;\n  }\n\n  public serialize() {\n    return JSON.stringify(this);\n  }\n}\n\nclass Circle implements Shape {\n\n  public radius: number;\n\n  public area() {\n    return this.radius * this.radius * Math.PI;\n  }\n\n  public serialize() {\n    return JSON.stringify(this);\n  }\n}\n</code></pre>\n<p>Нашему <em>domain layer</em> нужен метод area (из интерфейса Shape), но он не должен ничего знать о сериализации:</p>\n<pre><code class=\"language-typescript\">function getArea(shapes: Shape[]) {\n  return shapes.reduce(\n    (previous, current) => previous + current.area(),\n    0\n  );\n}\n</code></pre>\n<p>Нашему <em>infrastructure layer</em> нужен метод serialize (из интерфейса Shape), но он не должен ничего знать об area:</p>\n<pre><code class=\"language-typescript\">// ...\nreturn rectangle.serialize();\n</code></pre>\n<p>Проблема в том, что добавляя метод Serialize в интерфейс Shape мы нарушаем <em>separation of concerns principle</em> и\n<em>single responsibility principle</em>. Shape - сущность business layer, а возможность быть сериализованным - сущность\n<em>infrastructure layer</em>. Мы не должны смешивать эти два concern’а в одном интерфейсе.</p>\n<p><em>Interface segregation</em> говорит, что много небольших интерфейсов лучше, чем один большой, а это значит, что мы\nдолжны разделить наши интерфейсы:</p>\n<pre><code class=\"language-typescript\">interface RectangleInterface {\n  width: number;\n  height: number;\n}\n\ninterface CircleInterface {\n  radius: number;\n}\n\ninterface Shape {\n  area(): number;\n}\n\ninterface Serializable {\n  serialize(): string;\n}\n</code></pre>\n<p>При помощи наших новых интерфейсов, мы можем полностью изолировать наш доменный слой от такой инфраструктурной\nлогики, как сериализация:</p>\n<pre><code class=\"language-typescript\">class Rectangle implements RectangleInterface, Shape {\n\n  public width: number;\n  public height: number;\n\n  public area() {\n    return this.width * this.height;\n  }\n}\n\nclass Circle implements CircleInterface, Shape {\n\n  public radius: number;\n\n  public area() {\n    return this.radius * this.radius * Math.PI;\n  }\n}\n\nfunction getArea(shapes: Shape[]) {\n  return shapes.reduce(\n    (previous, current) => previous + current.area(),\n    0\n  );\n}\n</code></pre>\n<p>В инфраструктурном слое мы можем использовать новый набор сущностей, которые работают с сериализацией:</p>\n<pre><code class=\"language-typescript\">class RectangleDTO implements RectangleInterface, Serializable {\n\n  public width: number;\n  public height: number;\n\n  public serialize() {\n    return JSON.stringify(this);\n  }\n}\n\nclass CircleDTO implements CircleInterface, Serializable {\n\n  public radius: number;\n\n  public serialize() {\n    return JSON.stringify(this);\n  }\n}\n</code></pre>\n<p>Разбиение одного интерфейса общего назначения на множетсво специфичных позволяет нам предотвратить нарушение принципа\n<em>separation of concerns principle</em> (<em>business layer</em> ничего не знает о сериализации) и <em>single responsibility principle</em>\n(у нас нет <em>God Class</em>, который знает и о сериализации и о вычислении площади).</p>\n<p>С другой стороны, можно сказать, что классы RectangleDTO и Rectangle почти идентичны и это нарушает принцип <a href=\"https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself\">DRY</a>.\nНо, я так не думаю, потому что, хоть они и выглядят похоже, но относятся к разным Concern’ам. Когда два куска кода\nпохожи, это не всегда обозначает, что они выполняют одни и те же задачи.</p>\n<p>Однако, даже если принцип DRY все же нарушен, то нам приходится выбирать между принципами DRY и SOLID. И мне кажется,\nчто принцип DRY менее важен и ради принципов <em>SOLID</em> я готов “Repeat Myself”.</p>\n<h2 id=\"dependency-inversion-principle\" style=\"position:relative;\"><a href=\"#dependency-inversion-principle\" aria-label=\"dependency inversion principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DEPENDENCY INVERSION PRINCIPLE</h2>\n<p>Код должен зависеть от абстракций, а не от реализаций</p>\n<p>Dependency inversion principle говорит нам, что наш код всегда должен зависеть от интерфейсов, а не от классов.</p>\n<p>Важно понимать, что <em>Dependency inversion</em> и <em>Dependency injection</em> это не одно и то же.</p>\n<p>К сожалению, <em>dependency inversion principle</em> представлен буквой D в SOLID. Этот принцип идет последним, однако,\nявляется самым важным принципом в <em>SOLID</em>. Без <em>dependency inversion principle</em> другие принципы <em>SOLID</em> неосуществимы.</p>\n<p>Если мы вернемся назад и посмотрим на предыдущие принципы, станет очевидно, что использование интерфейсов - одно\nиз основных правил:</p>\n<ul>\n<li>Зависимость от интерфейсов, что следует из <em>interface segregation principle</em>, позволяет нам изолировать слой от деталей\nреализации другого слоя (<em>separation of concerns principle</em>) и позволяет предотвратить нарушение\n<em>single responsibility principle</em></li>\n<li>Зависимость от интерфейса также позволяет нам заменить одну реализацию другой (<em>Liskov substitution principle</em>)</li>\n<li>Зависимость от интерфейса позволяет нам писать приложения, которые открыты для расширения, но закрыты для\nмодификации (<em>Open/close principle</em>).\nСледование принципам SOLID в языке программирования, который не поддерживает интерфейсы или следует парадигме,\nкоторая не поддерживает полиморфизм, выглядит достаточно неестестенно. К таким языкам относятся ES5 и ES6.\nНо, к счастью, следовать принципам SOLID достаточно легко в Typescript.</li>\n</ul>\n<h1 id=\"the-model-view-controller-mvc-design-pattern\" style=\"position:relative;\"><a href=\"#the-model-view-controller-mvc-design-pattern\" aria-label=\"the model view controller mvc design pattern permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>THE MODEL-VIEW-CONTROLLER (MVC) DESIGN PATTERN</h1>\n<p>Паттерн проектирования MVC разделяет приложение на три основных части: <em>Модель</em>, <em>Представление</em> и <em>Контроллер</em>.</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/03.png\" alt=\"MVC\" title=\"MVC\"></p>\n<h2 id=\"model\" style=\"position:relative;\"><a href=\"#model\" aria-label=\"model permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MODEL</h2>\n<p>Объекты модели это часть приложения, отвечающая за логику доменных данных. Зачастую, объекты модели отвечают за\nполучение и сохранение состояния модели в базе данных. Например, объект Product может доставать информацию из базы,\nобновлять ее и потом записывать обновленную информацию обратно в таблицу Products в базы данных SQL.</p>\n<p>В небольших приложениях, модель зачастую является логической, а не физической сущностью. Например, если приложение\nтолько считывает набор данных и отправляет их в представление, приложение не имеет слоя моделей и соответствующих\nклассов. В таком случае, набор данных берет на себя роль модели.</p>\n<h2 id=\"view\" style=\"position:relative;\"><a href=\"#view\" aria-label=\"view permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VIEW</h2>\n<p>Представления это компоненты, которые отображают пользовательский интерфейс приложения. Как правило, пользовательский\nинтерфейс пострен на основе данных модели.</p>\n<p>Например, форма редактирования таблицы Products, на которой могут быть текстовые поля, чекбоксы, селектбоксы,\nотображающие текущее состояние объекта Product.</p>\n<h2 id=\"controller\" style=\"position:relative;\"><a href=\"#controller\" aria-label=\"controller permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CONTROLLER</h2>\n<p>Контроллеры это компоненты, ответственные за обработку действий пользователя, работу с моделями и выбор представления\nдля отображения пользовательского интерфейса. В MVC приложении представление ответственно только за отображение\nинформации; контроллеры обрабатывают и отвечают на пользовательские действия. Например, контроллер обрабатывает\nзначения из адресной строки и передает эти значения в модель, которая может использовать эти значения для составления\nзапроса в базу данных.</p>\n<p>MVC паттерн помогает создавать приложения с четко разделенными частями логики (логика ввода, бизнес логика, логика\nинтерфейса) без жесткой связи между этими частями. Паттерн определяет, где каждая часть логики должна быть размещена\nв приложении. Логика пользовательского интерфейса должна находиться в представлении. Логика взаимодействия с\nпользователем - в контроллере, Бизнес-логика - в модели. Такое разделение помогает управлять компонентностью, во\nвремя разработки приложения, потому как позволяет сконцентрироваться на определенной части логики отдельно. Например,\nвы можете сконцентрироваться на представлении, не беспокоясь о бизнес логике.</p>\n<p>Избавление от жесткой связи между этими частями приложения также упрощает параллельную разработку. Например, один\nразработчик может работать над представлением, в то время, как другой будет занят логикой контроллера, а третий -\nбизнес логикой. Паттерн MVC - прекрасный пример разделения концернов ради упрощения поддержки приложения в будущем.</p>\n<h1 id=\"the-repository-and-the-data-mapper-design-patterns\" style=\"position:relative;\"><a href=\"#the-repository-and-the-data-mapper-design-patterns\" aria-label=\"the repository and the data mapper design patterns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>THE REPOSITORY AND THE DATA MAPPER DESIGN PATTERNS</h1>\n<p>Паттерн MVC позволяет нам разделить логику взаимодействия с пользователем, логику интерфейса и бизнес логику.\nОднако модель имеет слишком много ответственности. Мы можем использовать паттерн <em>repository</em>, чтобы разделить\nлогику взаимодействия с хранилищем данных и логику манипуляции с данными. Слой бизнес логики не должен что-либо\nзнать о том, как эти данные хранятся. Например, мы можем хранить данные в базе данных, статическом файле или\nвеб сервисе.</p>\n<p>Репозиторий связывает слой доступа к данным и слой бизнес логики приложения. Он запрашивает данные из хранилища,\nпреобразовывает данные в бизнес сущности и сохраняет изменения бизнес сущности в хранилище. Репозиторий отделяет\nбизнес логику от взаимодействия с хранилищем данных. Такое разделение дает следующие преимущества:</p>\n<ul>\n<li>позволяет хранить всю логику работы с хранилищем данных в отдельном месте</li>\n<li>облегчает юнит-тестирование</li>\n<li>помогает построить гибкую, адаптируемую, масштабируемую архитектуру</li>\n</ul>\n<p>Репозиторий запрашивает данные для нужд пользователей и возвращает соответствующие результатам наборы бизнес сущностей.\nРепозиторий также сохраняет в хранилище добавленные или измененные бизнес сущности. Данная диаграмма изображает\nвзаимодействие репозитория с клиентом и источником данных.</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/04.png\" alt=\"DATA MAPPER\" title=\"DATA MAPPER\"></p>\n<p>Репозитории являются мостами между данными и операциями над данными, которые находятся на разных слоях приложения.\nВ обязанности репозитория также входит конвертация данных из формата, в котором данные хранятся в хранилище в формат\nдоменных сущностей. Зачастую, для этой конвертации используется паттерн <em>Data Mapper</em>.</p>\n<p>Репозиторий убирает жесткую зависимость от используемых технологий хранения данных. Например, если нам нужно получить\nнекоторые данные о продуктах, мы просто обратимся к интерфейсу репозитория и он вернет нам запрашиваемые доменные\nсущности. Нам нет необходимости знать, как именно хранятся данные: в SQL базе данных или, например в SharePoint CAML.\nПодобная изоляция существенно облегчает масштабирование приложения.</p>\n<h1 id=\"the-onion-architecture\" style=\"position:relative;\"><a href=\"#the-onion-architecture\" aria-label=\"the onion architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>THE ONION ARCHITECTURE</h1>\n<p>Onion architecture разбивает приложение на слои (похоже на луковицу):</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/05.png\" alt=\"Onion architecture\" title=\"Onion architecture\"></p>\n<p>Центральный слой - доменная модель. Вокруг нее расположены доменные сервисы, сервисы приложения и, на внешнем слое,\nтесты, инфраструктура и пользовательский интерфейс.</p>\n<p>В <a href=\"https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\">DDD</a>\n(<em>Domain Driven Development</em>) в центре всего находится т.н. ”<em>Domain</em>”. Домен состоит из двух компонентов:</p>\n<ul>\n<li>Доменная модель</li>\n<li>Доменные сервисы</li>\n</ul>\n<p>В функциональном программировании, один из основных архитектурных принципов заключается в том, чтобы помещать\n<a href=\"https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)\"><em>side-effects</em></a>\nна границах приложения. <em>Onion architecture</em> также следует этому принципу. Ядро приложения (доменные\nсервисы и доменные модели) должны быть отделены от <em>side-effect</em>‘ов и прочих деталей реализации. То есть, в ядре\nприложения не должно быть никаких ссылок, например, на реализацию хранилища данных (SQL) или транспорта данных (HTTP).</p>\n<p>Доменные модели и доменные сервисы не знают ничего о базах данных, протоколах, кеше и других специфичных для\nприложения решениях. Ядро приложения отвечает только за бизнес логику. Внешние слои приложения (<em>infrastructure,\ntest</em> и <em>user interface</em>) отвечают за взаимодействие с ресурсами (сеть, хранилище) и могут содержать и изолировать от\nядра <em>side-effect</em>‘ов.</p>\n<p>Такое разделение слоев достигается путем использования интерфейсов и следования <em>dependency inversion principle</em>:\nкомпонент должен зависеть от абстракций (интерфейсы), а не от реализаций (классы). Например, один из\nинфраструктурных слоев - слой HTTP полностью состоит из контроллеров. Контроллер AircraftController может\nзависеть от интерфейса AircraftRepository:</p>\n<pre><code class=\"language-typescript\">import { inject } from \"inversify\";\nimport { response, controller, httpGet } from \"inversify-express-utils\";\nimport * as express from \"express\";\nimport { AircraftRepository } from \"@domain/interfaces\";\nimport { Aircraft } from \"@domain/entitites/aircraft\";\nimport { TYPE } from \"@domain/types\";\n\n@controller(\"/api/v1/aircraft\")\nexport class AircraftController {\n\n    @inject(TYPE.AircraftRepository) private readonly _aircraftRepository: AircraftRepository;\n\n    @httpGet(\"/\")\n    public async get(@response() res: express.Response) {\n        try {\n            return await this._aircraftRepository.readAll();\n        } catch (e) {\n            res.status(500).send({ error: \"Internal server error\" });\n        }\n    }\n\n    // ...\n}\n</code></pre>\n<p>AircraftController является частью слоя инфраструктуры и его основная ответственность — взаимодействовать с HTTP\nи репозиторием AircraftRepository. AircraftRepository должен быть полностью изолирован от любой HTTP логики.\nС такой точкой зрения, наш граф зависимостей будет выглядеть так:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/06.png\" alt=\"AircraftRepository\" title=\"AircraftRepository\"></p>\n<p>Стрелочки на диаграмме имеют различное значение. Стрелочка “comp” обозначает, что AircraftRepository является\nсвойством AircraftController. Стрелочка “ref” обозначает, что AircraftController ссылается или зависит от Aircraft.</p>\n<p>Интерфейс AircraftRepository это часть <em>Domain Services</em>, в то время, как AircraftController и реализация\nAircraftRepository являются частью <em>Infrastructure Layer</em>:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/07.png\" alt=\"Onion architecture description\" title=\"Onion architecture description\"></p>\n<p>Это обозначает что один из внешних слоев (инфраструктурный) ссылается на один из внутренних (доменные сервисы).\nВ <em>Onion architecture</em> можно ссылаться только из внешних слоев во внутренние, но не в обратную сторону:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/08.png\" alt=\"Onion architecture flow\" title=\"Onion architecture flow\"></p>\n<p>Мы используем интерфейс AircraftRepository чтобы разделить слой домена от слоя инфраструктуры на этапе проектирования.\nОднако во время выполнения программы, эти два слоя должны как-то коммуникатировать. Эта коммуникация между\nинтерфейсами и реализациями управляется InversifyJS. InversifyJS позволяет нам объявлять инджектируемые\nзависимости при помощи декоратора @inject. На этапе проектирования мы можем объявить, что мы хотим использовать\nнужную реализацию для определенного интерфейса:</p>\n<pre><code class=\"language-typescript\">@inject(TYPE.AircraftRepository) private readonly _aircraftRepository: AircraftRepository;\n</code></pre>\n<p>Во время выполнения приложения, InversifyJS будет использовать данные настройки, чтобы инджектить нужную реализацию интерфейса:</p>\n<pre><code class=\"language-typescript\">container.bind&#x3C;AircraftRepository>(TYPE.AircraftRepository).to(AircraftRepositoryImpl);\n</code></pre>\n<p>Давайте посмотрим на AircratRepository и  Repository интерфейсы, которые являются частью слоя <em>Domain Services</em>.</p>\n<pre><code class=\"language-typescript\">import { Aircraft } from \"@domain/entitites/aircraft\";\n\nexport interface Repository&#x3C;T> {\n    readAll(): Promise&#x3C;T[]>;\n    readOneById(id: string): Promise&#x3C;T>;\n    // ...\n}\n\nexport interface AircraftRepository extends Repository&#x3C;Aircraft> {\n    // Add custom methods here ...\n}\n</code></pre>\n<p>На данный момент, граф зависимостей будет выглядеть следующим образом:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/09.png\" alt=\"Injections graph\" title=\"Injections graph\"></p>\n<p>Нам необходимо реализовать интерфейсы Repository и AircraftRepository:</p>\n<ul>\n<li>Repository реализуем классом GenericRepositoryImpl</li>\n<li>AircraftRepository реализуем классом AircraftRepositoryImpl</li>\n</ul>\n<p>Так будет выглядеть реализация Repository:</p>\n<pre><code class=\"language-typescript\">import { injectable, unmanaged } from \"inversify\";\nimport { Repository } from \"@domain/interfaces\";\nimport { EntityDataMapper } from \"@dal/interfaces\";\nimport { Repository as TypeOrmRepository } from \"typeorm\";\n\n@injectable()\nexport class GenericRepositoryImpl&#x3C;TDomainEntity, TDalEntity> implements Repository&#x3C;TDomainEntity> {\n\n    private readonly _repository: TypeOrmRepository&#x3C;TDalEntity>;\n    private readonly _dataMapper: EntityDataMapper&#x3C;TDomainEntity, TDalEntity>;\n\n    public constructor(\n        @unmanaged() repository: TypeOrmRepository&#x3C;TDalEntity>,\n        @unmanaged() dataMapper: EntityDataMapper&#x3C;TDomainEntity, TDalEntity>\n    ) {\n        this._repository = repository;\n        this._dataMapper = dataMapper;\n    }\n\n    public async readAll() {\n        const entities = await this._repository.readAll();\n        return entities.map((e) => this._dataMapper.toDomain(e));\n    }\n\n    public async readOneById(id: string) {\n        const entity = await this._repository.readOne({ id });\n        return this._dataMapper.toDomain(entity);\n    }\n\n    // ...\n}\n</code></pre>\n<p>Данная реализация принимает EntityDataMapper и TypeOrmRepository в конструкторе, чтобы в дальнейшем использовать их\nдля получения и преобразования данных из базы данных в доменные сущности.</p>\n<p>Нам также необходим интерфейс EntityDataMapper:</p>\n<pre><code class=\"language-typescript\">export interface EntityDataMapper&#x3C;Domain, Entity> {\n\n    toDomain(entity: Entity): Domain;\n    toDalEntity(domain: Domain): Entity;\n}\n</code></pre>\n<p>И его реализация:</p>\n<pre><code class=\"language-typescript\">import { toDateOrNull, toLocalDateOrNull } from \"@lib/universal/utils/date_utils\";\nimport { Aircraft } from \"@domain/entitites/aircraft\";\nimport { AircraftEntity } from \"@dal/entities/aircraft\";\nimport { EntityDataMapper } from \"@dal/interfaces\";\n\nexport class AircraftDataMapper implements EntityDataMapper&#x3C;Aircraft, AircraftEntity> {\n\n    public toDomain(entity: AircraftEntity): Aircraft {\n        // ...\n    }\n\n    public toDalEntity(mortgage: Aircraft): AircraftEntity {\n        // ...\n    }\n}\n</code></pre>\n<p>В нашем случае, EntityDataMapper преобразовывает данные полученные из TypeOrmRepository в доменные сущности.</p>\n<p>На данный момент, наш граф зависимостей будет выглядеть так:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/10.png\" alt=\"Injections graph 2\" title=\"Injections graph 2\"></p>\n<p>И наконец, давайте напишем реализацию AircraftRepository:</p>\n<pre><code class=\"language-typescript\">import { inject, injectable } from \"inversify\";\nimport { Repository as TypeOrmRepository } from \"typeorm\";\nimport { AircraftRepository } from \"@domain/interfaces\";\nimport { Aircraft } from \"@domain/entitites/aircraft\";\nimport { GenericRepositoryImpl } from \"@dal/generic_repository\";\nimport { AircraftEntity } from \"@dal/entities/aircraft\";\nimport { AircraftDataMapper } from \"@dal/data_mappers/aircraft\";\nimport { TYPE } from \"@dal/types\";\n\n@injectable()\nexport class AircraftRepositoryImpl\n    extends GenericRepositoryImpl&#x3C;Aircraft, AircraftEntity>\n    implements AircraftRepository {\n\n    public constructor(\n        @inject(TYPE.TypeOrmRepositoryOfAircraftEntity) repository: TypeOrmRepository&#x3C;AircraftEntity>\n    ) {\n        super(repository, new AircraftDataMapper())\n    }\n\n    // Add custom methods here ...\n\n}\n</code></pre>\n<p>И обновленный граф зависимостей будет таким:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/11.png\" alt=\"Injections graph 3\" title=\"Injections graph 3\"></p>\n<p>На данной диаграмме синим цветом выделены реализации, а желтым - абстракции.</p>\n<p>На диаграмме ниже, зеленым выделены компоненты слоя домена и синим - компоненты слоя инфраструктуры:</p>\n<p><img src=\"/media/2019-01-01-implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs/12.png\" alt=\"Injections graph 4\" title=\"Injections graph 4\"></p>\n<p>Я успешно использую эту архитектуру в больших интерпрайз приложениях на протяжении последних 10 лет.\nТакже можно разбивать большие слои на отдельные микросервисы. Решение, когда множество микросервисов реализуют\n<em>onion architecture</em>, я называю “мешок лука”.</p>\n<h1 id=\"интересные-ссылки\" style=\"position:relative;\"><a href=\"#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B5%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8\" aria-label=\"интересные ссылки permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ИНТЕРЕСНЫЕ ССЫЛКИ</h1>\n<ul>\n<li><a href=\"https://github.com/stelltec/public-tech-demos/tree/master/nodejs-madrid-meetup/demo3\">Git репозиторий с примером простой реализации луковой архитектуры при помощи Typescript и InversifyJS</a></li>\n<li><a href=\"https://kristopher.codes/2013/07/04/implementing-the-onion-architecture-in-php/\">Реализация Onion Architecture на PHP</a></li>\n<li><a href=\"https://medium.com/@matthew.erskine/laravel-5-x-onion-architecture-c81a3d5918f2\">Реализация Onion Architecture при помощи Laravel</a></li>\n</ul>","fields":{"slug":"/posts/implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs","tagSlugs":["/tag/the clean architecture","/tag/onion architecture","/tag/ddd","/tag/solid","/tag/typescript","/tag/inversifyjs","/tag/nodejs","/tag/mvc"],"categorySlug":"/category/development"},"frontmatter":{"date":"2019-01-01T16:28:32.000Z","description":"Remo H. Jansen, the clean architecture, onion architecture, ddd, solid, typescript, inversifyjs, nodejs, mvc","category":"development","tags":["the clean architecture","onion architecture","ddd","solid","typescript","inversifyjs","nodejs","mvc"],"title":"IMPLEMENTING SOLID AND THE ONION ARCHITECTURE IN NODE.JS WITH TYPESCRIPT AND INVERSIFYJS"}}},"pageContext":{"slug":"/posts/implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs","allCategories":[{"fieldValue":"development","totalCount":3,"categoryColor":"pink-600"},{"fieldValue":"recipes","totalCount":2,"categoryColor":"green-600"}]}},"staticQueryHashes":["2052939023","251939775","401334301"]}