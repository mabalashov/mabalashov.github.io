{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/symfony-messenger-in-laravel","result":{"data":{"markdownRemark":{"id":"6cd1370c-e04f-516e-b572-93b1e147d4e1","html":"<h4 id=\"проблемы-коммуникаций-микросервисов-написанных-на-разных-технологиях-глубокая-кастомизация-командной-шины-laravel\" style=\"position:relative;\"><a href=\"#%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D0%BA%D0%BE%D0%BC%D0%BC%D1%83%D0%BD%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B9-%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BD%D0%B0-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F%D1%85-%D0%B3%D0%BB%D1%83%D0%B1%D0%BE%D0%BA%D0%B0%D1%8F-%D0%BA%D0%B0%D1%81%D1%82%D0%BE%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%BE%D0%B9-%D1%88%D0%B8%D0%BD%D1%8B-laravel\" aria-label=\"проблемы коммуникаций микросервисов написанных на разных технологиях глубокая кастомизация командной шины laravel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Проблемы коммуникаций микросервисов, написанных на разных технологиях. Глубокая кастомизация командной шины Laravel</h4>\n<hr>\n<p><img src=\"/media/2020-11-29-symfony-messenger-in-laravel/message-broker.png\" alt=\"Message Broker\" title=\"Message Broker\"></p>\n<h2 id=\"предпосылка\" style=\"position:relative;\"><a href=\"#%D0%BF%D1%80%D0%B5%D0%B4%D0%BF%D0%BE%D1%81%D1%8B%D0%BB%D0%BA%D0%B0\" aria-label=\"предпосылка permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ПРЕДПОСЫЛКА</h2>\n<p>Недавно появилась необходимость написать некоторый микросервис в уже существующем приложении.\nПри написании сервиса не было повышенных требований к надежности и расширяемости, но и написать его нужно было крайне\nбыстро. Потому, выбор пал на использование Laravel.\nОднако остальные микросервисы были написаны на Symfony и Go, поэтому возникла небольшая проблема в коммуникациях,\nрешение которой представлено ниже</p>\n<h1 id=\"laravel\" style=\"position:relative;\"><a href=\"#laravel\" aria-label=\"laravel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Laravel</h1>\n<p><img src=\"/media/2020-11-29-symfony-messenger-in-laravel/laravel.png\" alt=\"Laravel\" title=\"Laravel\"></p>\n<h3 id=\"плюсы\" style=\"position:relative;\"><a href=\"#%D0%BF%D0%BB%D1%8E%D1%81%D1%8B\" aria-label=\"плюсы permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Плюсы</h3>\n<p>Laravel - замечательный фреймворк с дружелюбным сообществом и огромной экосистемой, занявший свою нишу.\nФреймворк очень быстро развивается и практически для каждой задачи уже есть своя реализация оформленная\nв виде пакета для Laravel.</p>\n<p>Laravel идеально подходит для небольших и средних проектов, а также для MVP, из-за того, что всё необходимое\nуже есть в коробке, а чего нет - можно быстро установить.</p>\n<p>Скорости разработки способствуют инструменты предоставляемые фреймворком (которые,\nне всегда можно назвать эталоном хорошего дизайна. Например Laravel Facade по сути являющийся синглтоном).</p>\n<p>Также стоит упомянуть, что в коробке Laravel лежит Eloquent, который по сути является реализацией паттерна\nActive Record. В отличие от Data Mapper’a, ActiveRecord даёт огромный прирост скорости разработки в ущерб\nчистоте дизайна и невозможности следования принципу <a href=\"/posts/implementing-solid-and-onion-architecture-nodejs-typescript-and-inversifyjs#single-responsibility-principle\">SRP</a></p>\n<p>Из-за этого, написать небольшой демон на Laravel иногда бывает в 2 раза быстрее, нежели, к примеру, на Symfony.</p>\n<h3 id=\"минусы\" style=\"position:relative;\"><a href=\"#%D0%BC%D0%B8%D0%BD%D1%83%D1%81%D1%8B\" aria-label=\"минусы permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Минусы</h3>\n<p>Однако с ростом проекта появляются подводные камни, которые не были видны при первом знакомстве</p>\n<p>Laravel, мягко говоря, не очень экономичный и это относится как к нагрузке на RAM, так и на CPU.</p>\n<p>Также, разрабатывая крупное приложение на Laravel, становится сложно придерживаться принципам чистой\nархитектуры. Мы просто “закрываем глаза” на “костыли”, которые написаны “на коленке” и просто работают.\nНо как только приложение начинает расти эти костыли превращаются в технический долг со всеми вытекающими.</p>\n<p>Есть еще один минус Laravel: некоторые компоненты очень глубоко интегрированы во фреймворк и кастомизировать их\nдовольно проблемно</p>\n<h3 id=\"проблема\" style=\"position:relative;\"><a href=\"#%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0\" aria-label=\"проблема permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Проблема</h3>\n<p>В Laravel существует командная шина, но настраивать её крайне сложно. Невозможно изменить формат сообщений и\nправила выбора обработчика сообщения. И простой заменой <a href=\"https://tactician.thephpleague.com/\">командной шины</a> проблема не решится.\nЕсли нам приходится коммуницировать с микросервисами, использующими свой формат,\nнеобходимо будет городить свой велосипед, чтобы на более низком уровне парсить входящие сообщения и определять, что\nдальше с ними делать. Также стоит всегда помнить, что транспорт может быть изменен и наш велосипед должен перестроиться\nна использование нового транспорта за довольно короткое время.</p>\n<p>Как альтернативное решение — можно воспользоваться уже готовыми компонентами, а именно <code>symfony/messenger</code></p>\n<p>Компоненты Symfony традиционно предоставляют удивительную гибкость и <a href=\"https://github.com/laravel/framework/blob/8.x/src/Illuminate/Validation/Validator.php#L492\">чистый код</a>,\nоднако порог вхождения для них иногда немного выше. </p>\n<h1 id=\"брокеры-сообщений\" style=\"position:relative;\"><a href=\"#%D0%B1%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9\" aria-label=\"брокеры сообщений permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Брокеры сообщений</h1>\n<p>Существует ряд решений для реализации брокера сообщений. Самые популярные реализованы при помощи amqp, redis и sqs.</p>\n<h3 id=\"amqp\" style=\"position:relative;\"><a href=\"#amqp\" aria-label=\"amqp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AMQP</h3>\n<p><img src=\"/media/2020-11-29-symfony-messenger-in-laravel/amqp.png\" alt=\"AMQP\" title=\"AMQP\"></p>\n<p>Специально для передачи сообщений между различными компонентами, существует протокол <a href=\"https://ru.wikipedia.org/wiki/AMQP\">AMQP</a>.</p>\n<p>Исторически так сложилось, что существуют версии протокола 1.* и 0.9.1, которые не совместимы между собой.</p>\n<p>Самые известные реализации протокола версии 1.* это</p>\n<ul>\n<li><a href=\"https://solace.com/\">Solace</a></li>\n<li><a href=\"http://activemq.apache.org/\">ActiveMQ</a></li>\n<li><a href=\"https://qpid.apache.org/\">Qpid</a></li>\n</ul>\n<p>для версии 0.9.1 это</p>\n<ul>\n<li><a href=\"https://www.rabbitmq.com/\">RabbitMQ</a></li>\n<li><a href=\"http://gearman.org/\">Gearman</a></li>\n</ul>\n<p>В мире PHP, как правило, применяется AMQP 0.9.1 и главенствующую роль занимает RabbitMQ.\nRabbitMQ также при помощи <a href=\"https://github.com/rabbitmq/rabbitmq-amqp1.0/blob/v3.7.x/README.md\">плагина</a> может поддерживать AMQP 1.</p>\n<p>До последнего момента AWS не поддерживал RabbitMQ встроенными сервисами, но буквально на днях всё же\nдобавили такую <a href=\"https://aws.amazon.com/ru/about-aws/whats-new/2020/11/announcing-amazon-mq-rabbitmq/\">возможность</a>.</p>\n<p>Поэтому, если инфраструктура находится на AWS, необходимо было подымать отдельный инстанс EC2, в котором разворачивать\nобраз с RabbitMQ, однако сейчас можно поднять high availability rabbit кластер буквально в несколько кликов.</p>\n<h3 id=\"redis\" style=\"position:relative;\"><a href=\"#redis\" aria-label=\"redis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redis</h3>\n<p><img src=\"/media/2020-11-29-symfony-messenger-in-laravel/redis.png\" alt=\"Redis\" title=\"Redis\"></p>\n<p>В данном примере мы будем использовать redis, как самый простой способ.\nНачиная с версии 5.0 в Redis добавлен тип <a href=\"https://habr.com/ru/post/456270/\">Redis Stream</a> идеально подходящий для\nреализации очередей.</p>\n<p>Также, redis поддерживает возможность создания <a href=\"https://redis.io/topics/cluster-tutorial\">кластеров</a>\nдля достижения high availability. Но, всё уже также <a href=\"https://aws.amazon.com/ru/redis/\">реализовано</a> в AWS.</p>\n<p>Если производительности Redis’а недостаточно, стоит посмотреть в сторону <a href=\"https://keydb.dev/\">KeyDB</a> полностью\nсовместимый с redis’ом, но работающий гораздо шустрее.</p>\n<h3 id=\"sqs\" style=\"position:relative;\"><a href=\"#sqs\" aria-label=\"sqs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQS</h3>\n<p>У AWS есть собственный брокера сообщений — sqs. Но по опыту работы, сталкивался с рядом проблем и как\nуниверсальное решение этих проблем был выбран переезд на RabbitMQ</p>\n<p>Из известных проблем можно отметить отсутствие гарантии, что сообщение будет доставлено всего один раз;\nпорядок доставки сообщений тоже не гарантируется;\nчастые ошибки 503 и вообще sqs работает поверх http, со всеми вытекающими проблемами</p>\n<p>Из плюсов можно отметить надежность, неограниченный размер очереди и персистентность хранилища по умолчанию</p>\n<h3 id=\"остальные\" style=\"position:relative;\"><a href=\"#%D0%BE%D1%81%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5\" aria-label=\"остальные permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Остальные</h3>\n<p>Список брокеров сообщений не заканчивается описанными выше. Более полный список можно найти, например, на странице в\n<a href=\"https://en.wikipedia.org/wiki/Message_broker#List_of_message_broker_software\">википедии</a></p>\n<h1 id=\"практика\" style=\"position:relative;\"><a href=\"#%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0\" aria-label=\"практика permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Практика</h1>\n<h2 id=\"подготовка\" style=\"position:relative;\"><a href=\"#%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0\" aria-label=\"подготовка permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Подготовка</h2>\n<p>Итак, перед нами проект на Laravel и мы готовы установить <a href=\"https://symfony.com/doc/current/messenger.html\">Symfony Messenger</a>\nдля коммуникации с другими сервисами.</p>\n<p><img src=\"/media/2020-11-29-symfony-messenger-in-laravel/got-symfony.jpg\" alt=\"Got Symfony\" title=\"Got Symfony\"></p>\n<p>Нам понадобится пакет <a href=\"https://github.com/symfony/messenger\"><code>symfony/messenger</code></a>\nEсли мы хотим использовать Redis, то нам еще пригодятся <a href=\"https://github.com/predis/predis\"><code>predis/predis</code></a> и\n<a href=\"https://github.com/symfony/redis-messenger\"><code>symfony/redis-messenger</code></a>, в который с версии 5.1 был вынесен код для работы с redis:</p>\n<pre><code class=\"language-bash\">composer require symfony/messenger symfony/redis-messenger predis/predis\n</code></pre>\n<h2 id=\"сериализация\" style=\"position:relative;\"><a href=\"#%D1%81%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F\" aria-label=\"сериализация permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Сериализация</h2>\n<p>Прежде чем отправлять или получать сообщения, стоит поговорить о сериализации сообщений.</p>\n<p>Для того, чтобы указать, как наши сообщения должны быть сериализованы и десериализованы в очереди, нам необходимо\nсоздать (или использовать существующий) класс, имплементирующий интерфейс <code>Symfony\\Component\\Messenger\\Transport\\Serialization\\SerializerInterface</code>:</p>\n<pre><code class=\"language-php\">use Symfony\\Component\\Messenger\\Envelope;\n\ninterface SerializerInterface\n{\n    public function decode(array $encodedEnvelope): Envelope;\n\n    public function encode(Envelope $envelope): array;\n}\n</code></pre>\n<p>Для работы с сообщениями принято оборачивать их в специальный класс <a href=\"https://symfony.com/doc/current/components/messenger.html#adding-metadata-to-messages-envelopes\">Envelope</a>,\nкоторый содержит как само сообщение, так и <code>stamps</code> - набор меток содержащих метаданные сообщения.\nСписок возможных <code>stamp</code>‘ов и описание работы с ними можно найти в документации </p>\n<p>Итого, наш сериализатор должен уметь кодировать сообщение (превращать <code>Envelope</code> в некоторый массив) и декодировать (превращать обратно).\nДанные этого массива и будут путешествовать через брокер сообщений.</p>\n<p>Стоит обратить внимание, что для корректной работы с транспортами, массив, в который мы будем кодировать сообщение,\nдолжен содержать два поля:</p>\n<ul>\n<li><code>headers</code> — метаданные сообщения </li>\n<li><code>body</code> — само тело сообщения </li>\n</ul>\n<p><em>К сожалению, это ограничение Symfony Messenger’а и заставить его работать с сообщениями, не имеющими такую структуру\nневозможно.</em></p>\n<p>При десериализации, мы должны указать, в какой <a href=\"https://ru.wikipedia.org/wiki/DTO\">объект</a> сообщения мы должны\nпреобразовать полученные данные. Самый простой вариант — передать полное имя конечного класса вместе с сообщением.\nНо этот способ не подходит, когда мы передаем сообщение из другого сервиса, классы которого могут не совпадать с нашими.</p>\n<p>В таком случае, ответственность за маппинг данных в нужный объект лежит полностью на нас.</p>\n<p>Для примера давайте напишем простейший объект, в который можно засунуть абсолютно любые данные:</p>\n<pre><code class=\"language-php\">class Message\n{\n    private array $payload;\n\n    public function __construct(array $payload)\n    {\n        $this->payload = $payload;\n    }\n\n    public function getPayload(): array\n    {\n        return $this->payload;\n    }\n}\n</code></pre>\n<p>В таком случае, метод <code>decode</code> нашего <code>Serializer</code>‘а может выглядеть так:</p>\n<pre><code class=\"language-php\">    public function decode(array $encodedEnvelope): Envelope\n    {\n        $body = $encodedEnvelope['body'];\n\n        $message = new Message(\\json_decode($body, true));\n\n        return new Envelope($message, []);\n    }\n</code></pre>\n<p>Здесь и далее мы намеренно игнорируем <code>headers</code> и не получаем <code>stamps</code> для упрощения примера.\nВместо них вторым аргументом в конструктор <code>Envelope</code> мы передаём пустой массив. В реальном приложении конечно не стоит так делать.</p>\n<p>Напишем обратный метод <code>encode</code>:</p>\n<pre><code class=\"language-php\">    public function encode(Envelope $envelope): array\n    {\n        /** @var Message $message */\n        $message = $envelope->getMessage();\n\n        return [\n            'body' => \\json_encode($message->getPayload()),\n            'headers' => [],\n        ];\n    }\n</code></pre>\n<p>Обратим внимание, что здесь мы также пренебрегли <code>headers</code>.</p>\n<p>Таким образом мы создали простейший сериализатор, который способен работать с любыми входящими сообщениями.\nСкорее всего, в реальном проекте, он будет гораздо сложнее.\nДело не должно ограничиваться одним универсальным сообщением, а сериализация банальным <code>json_encode</code>.</p>\n<p>Стоит обратить внимание на компонент <a href=\"https://symfony.com/doc/current/components/serializer.html\">Symfony Serializer</a>,\nкоторый является универсальным мощным решением для вопросов сериализации.</p>\n<p>Пример использование этого компонента для работы с Symfony Messenger можно найти например\n<a href=\"https://blog.liplex.de/symfony-messenger-with-custom-serializer/\">вот здесь</a>.</p>\n<h2 id=\"отправка\" style=\"position:relative;\"><a href=\"#%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0\" aria-label=\"отправка permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Отправка</h2>\n<h3 id=\"senderinterface\" style=\"position:relative;\"><a href=\"#senderinterface\" aria-label=\"senderinterface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SenderInterface</h3>\n<p>Чтобы отправить сообщение в очередь, необходимо создать инстанс имплементирующий интерфейс\n<code>\\Symfony\\Component\\Messenger\\Transport\\Sender\\SenderInterface</code>. </p>\n<p>Symfony предоставляет нам ряд реализаций этого интерфейса для различных транспортов:</p>\n<p><img src=\"/media/2020-11-29-symfony-messenger-in-laravel/sender-interface-realizations.png\" alt=\"sender-interface-realization\" title=\"Sender Interface Realization\"></p>\n<p>Нас интересует <code>RedisSender</code></p>\n<p>Конструктор ожидает объект <code>Connection</code> и <code>Serializator</code>, который мы создали ранее.</p>\n<p>Connection проще всего создать при помощи порождающего метода <code>Connection::fromDsn</code>. Итого, у нас должно получиться\nчто-то подобное:</p>\n<pre><code class=\"language-php\">use Symfony\\Component\\Messenger\\Bridge\\Redis\\Transport\\Connection;\nuse Symfony\\Component\\Messenger\\Bridge\\Redis\\Transport\\RedisSender;\nuse App\\Bus\\MySerializer;\n\n// ...\n\n$serializer = new MySerializer();\n$connection = Connection::fromDsn('localhost:6379/queue');\n\n$sender = new RedisSender($connection, $serializer);\n</code></pre>\n<p>Поскольку мы пишем на Laravel, то подобную инициализацию я бы рекомендовал положить в ServiceProvider и передавать\nобъекты через ServiceContainer, а dsn очереди хранить в конфигурационных файлах.</p>\n<p>Теперь простейшая отправка сообщения будет выглядеть примерно так:</p>\n<pre><code class=\"language-php\">use Ramsey\\Uuid\\Uuid;\nuse App\\Bus\\MyMessage;\nuse Symfony\\Component\\Messenger\\Bridge\\Redis\\Transport\\RedisSender;\n\n// ...\n\n$message = new MyMessage([\n    'id' => Uuid::uuid4(),\n]);\n\n$sender = app()->make(RedisSender::class);\n\n$sender->send(new Envelope($message));\n</code></pre>\n<h4 id=\"debug\" style=\"position:relative;\"><a href=\"#debug\" aria-label=\"debug permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Debug</h4>\n<p>При дебаге, чтобы проверить, что сообщение ушло в redis, можно во время отправки в риалтайме смотреть,\nчто отправляется в очередь следующей командой:</p>\n<pre><code class=\"language-bash\">redis-cli monitor | grep XADD\n</code></pre>\n<p>Мы должны будем увидеть что-то подобное:</p>\n<pre><code class=\"language-bash\">1606668667.252463 [0 [::1]:33480] \"XADD\" \"queue\" \"*\" \"message\" \"s:162:\\\"{\\\"body\\\":\\\"{\\\\\\\"payload\\\\\\\":{\\\\\\\"id\\\\\\\":\\\\\\\"6a2f15b0-c166-4863-a96e-b662901c9333\\\\\\\"}}\\\",\\\"headers\\\":{\\\"type\\\":\\\"App\\\\\\\\Bus\\\\\\\\Messages\\\\\\\\PingMessage\\\",\\\"Content-Type\\\":\\\"application\\\\/json\\\"}}\\\";\"\n16\n</code></pre>\n<h2 id=\"получение\" style=\"position:relative;\"><a href=\"#%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5\" aria-label=\"получение permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Получение</h2>\n<h3 id=\"receiverinterface\" style=\"position:relative;\"><a href=\"#receiverinterface\" aria-label=\"receiverinterface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ReceiverInterface</h3>\n<p>Для получения сообщений из очереди, по аналогии с <code>RedisSender</code> создадим инстанс класса\n<code>Symfony\\Component\\Messenger\\Bridge\\Redis\\Transport\\RedisReceiver</code>, имплементирующий интерфейс\n<code>Symfony\\Component\\Messenger\\Transport\\Receiver\\ReceiverInterface</code>:</p>\n<pre><code class=\"language-php\">use Symfony\\Component\\Messenger\\Bridge\\Redis\\Transport\\Connection;\nuse Symfony\\Component\\Messenger\\Bridge\\Redis\\Transport\\RedisReceiver;\nuse App\\Bus\\MySerializer;\n\n// ...\n\n$serializer = new MySerializer();\n$connection = Connection::fromDsn('localhost:6379/queue');\n\n$receiver = new RedisReceiver($connection, $serializer);\n</code></pre>\n<p>Теперь, чтобы начать получать из очереди сообщения, достаточно периодически опрашивать у <code>$receiver</code>‘а новые сообщения:</p>\n<pre><code class=\"language-php\">while (true) {\n    $envelopes = $receiver->get();\n    // ...\n}\n</code></pre>\n<h3 id=\"worker\" style=\"position:relative;\"><a href=\"#worker\" aria-label=\"worker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Worker</h3>\n<p>В принципе, такой способ будет работать, но лучше использовать предназначенный для такого\n<code>\\Symfony\\Component\\Messenger\\Worker</code>.</p>\n<p>Для минимальной инициализации <code>Worker</code> требуется передать массив <code>ReceiverInterface</code>, один из которых мы создали\nранее и шину сообщений, имплементирующую <code>Symfony\\Component\\Messenger\\MessageBusInterface</code>.</p>\n<p>Также, по-хорошему, крайне желательно (но не необходимо) передать ему <code>EventDispatcher</code> и <code>Logger</code>,\nно с этим проблем возникнуть не должно.</p>\n<h4 id=\"messagebusinterface\" style=\"position:relative;\"><a href=\"#messagebusinterface\" aria-label=\"messagebusinterface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MessageBusInterface</h4>\n<p>Более подробно про шину хорошо описано в <a href=\"https://symfony.com/doc/current/components/messenger.html#bus\">документации</a></p>\n<p>Самое интересное в ней для нас — список передаваемых в неё Middleware, с помощью которых можно гибко\nнастраивать роутинг получаемых сообщений и обрабатывающих их хендлеров.</p>\n<p>Напишем простейшую реализацию.</p>\n<p>Предположим, что у нас есть <code>Handler</code> сообщений, у которого реализован метод <code>handle</code>, при помощи которого мы будем\nобрабатывать входящие сообщениe <code>MyMessages</code>:</p>\n<pre><code class=\"language-php\">class MyMessageHandler {\n    public function handle(MyMessages $message)\n    {\n        // do something with $message \n    }\n}\n</code></pre>\n<p>Теперь создадим простейший <code>MesaageBus</code>, который будет просить <code>MyMessageHandler</code> обрабатывать все входящие\n<code>MyMessages</code>:</p>\n<pre><code class=\"language-php\">use Symfony\\Component\\Messenger\\Middleware\\HandleMessageMiddleware;\nuse Symfony\\Component\\Messenger\\Handler\\HandlersLocator;\nuse Symfony\\Component\\Messenger\\Handler\\HandlerDescriptor;\nuse Symfony\\Component\\Messenger\\MessageBus;\nuse App\\Bus\\MyMessage;\nuse App\\Bus\\MyMessageHandler;\n\n// ...\n\n$handlers = [\n    MyMessages::class => [\n        new HandlerDescriptor(\n            function (MyMessages $message) {\n                return app()->make(MyMessageHandler::class)->handle($message);\n            }\n        )\n    ],\n];\n\n$middleware = [\n    new HandleMessageMiddleware(\n        new HandlersLocator($handlers), false\n    )\n];\n\n$messageBus = new MessageBus($middleware);\n</code></pre>\n<p><em>Стоит обратить внимание, что в данном примере при получении каждого сообщения мы инстанциируем новый экземпляр\nкласса <code>MyMessageHandler</code>. Это достаточно безопасная практика, но при больших нагрузках у нас здесь будет просадка\nпроизводительности. Гораздо эффективнее использовать один и тот же закешированный инстанс класса, в который\nмы будем передавать наши сообщения. Но в таком случае нам необходимо следить за утечками памяти.</em>  </p>\n<h4 id=\"соберем-всё-вместе\" style=\"position:relative;\"><a href=\"#%D1%81%D0%BE%D0%B1%D0%B5%D1%80%D0%B5%D0%BC-%D0%B2%D1%81%D1%91-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B5\" aria-label=\"соберем всё вместе permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Соберем всё вместе</h4>\n<p>Итого, чтобы создать Worker, напишем следующее:</p>\n<pre><code class=\"language-php\">use Symfony\\Component\\Messenger\\Worker;\n\n// ...\n\n$receivers = [\n    $receiver,\n];\n\nreturn new Worker($receivers, $messageBus);\n</code></pre>\n<p>И теперь можно создать консольную команду, в которой запустить полученный <code>Worker</code>:</p>\n<pre><code class=\"language-php\">use Illuminate\\Console\\Command;\nuse Symfony\\Component\\Messenger\\Worker;\n\nclass RedisReceiver extends Command\n{\n    protected $signature = 'bus:receive';\n\n    public function handle(Worker $worker)\n    {\n        $worker->run();\n    }\n}\n</code></pre>\n<h1 id=\"исходный-код\" style=\"position:relative;\"><a href=\"#%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BE%D0%B4\" aria-label=\"исходный код permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Исходный код</h1>\n<p>Тестовый проект, использующий примеры из статьи можно найти в моём\n<a href=\"https://github.com/mabalashov/symfony-messenger-laravel-integration-example\">репозитории</a> на github.</p>\n<p>Все классы для работы с очередью можно найти в <code>\\App\\Bus\\*</code>, а создание необходимых Symfony-компонентов в\nСервис Провайдере <code>App\\Providers\\BusServiceProvider</code>. </p>\n<p>В README описаны действия как проверить работоспособность примера.</p>\n<p>Повторим в консоли в трёх окнах. В каждом окне зайдём в vagrant: </p>\n<pre><code class=\"language-bash\">vagrant up\nvagrant ssh\ncd /vagrant\n</code></pre>\n<p>В одном окне будем считывать очередь:</p>\n<pre><code class=\"language-bash\">php artisan bus:receive\n</code></pre>\n<p>Во втором — мониторить redis:</p>\n<pre><code class=\"language-bash\">redis-cli monitor | grep XADD\n</code></pre>\n<p>В третьем отправим сообщение:</p>\n<pre><code class=\"language-bash\">php artisan bus:dispatch\n</code></pre>\n<p>Если увидим что-то подобное, значит мы всё сделали правильно:</p>\n<p><img src=\"/media/2020-11-29-symfony-messenger-in-laravel/working-example.png\" alt=\"Working Example\" title=\"Working Example\"></p>\n<h1 id=\"интересные-ссылки\" style=\"position:relative;\"><a href=\"#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B5%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8\" aria-label=\"интересные ссылки permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ИНТЕРЕСНЫЕ ССЫЛКИ</h1>\n<ul>\n<li><a href=\"https://habr.com/ru/post/483584/\">Перевод PHP бэкенда на шину Redis streams и выбор независимой от фреймворков библиотеки\n</a></li>\n<li><a href=\"https://ruhighload.com/%d0%9e%d1%87%d0%b5%d1%80%d0%b5%d0%b4%d0%b8+%d1%81%d0%be%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d0%b9\">Очереди сообщений</a></li>\n</ul>","fields":{"slug":"/posts/symfony-messenger-in-laravel","tagSlugs":["/tag/laravel","/tag/symfony","/tag/microservices","/tag/php","/tag/redis","/tag/amqp","/tag/rabbitmq","/tag/aws"],"categorySlug":"/category/recipes"},"frontmatter":{"date":"2020-11-30T21:35:00.000Z","description":"Опыт использования компонента symfony/messenger в Laravel. Проблемы коммуникаций микросервисов, написанных на разных технологиях. Глубокая кастомизация командной шины Laravel ","category":"recipes","tags":["laravel","symfony","microservices","php","redis","amqp","rabbitmq","aws"],"title":"Использование symfony/messenger для работы с очередью сообщений в Laravel"}}},"pageContext":{"slug":"/posts/symfony-messenger-in-laravel","allCategories":[{"fieldValue":"development","totalCount":3,"categoryColor":"pink-600"},{"fieldValue":"recipes","totalCount":6,"categoryColor":"green-600"}]}},"staticQueryHashes":["2052939023","251939775","401334301"]}