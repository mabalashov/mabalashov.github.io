{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/the-clean-architecture","result":{"data":{"markdownRemark":{"id":"8afddec9-df76-51c6-97da-f4001d382265","html":"<h4 id=\"the-clean-architecture-описывает-основные-общие-правила-построения-архитектуры-приложения-как-сделать-разработку-тестируемой-удобной-понятной-а-части-системы-взаимозаменяемыми\" style=\"position:relative;\"><a href=\"#the-clean-architecture-%D0%BE%D0%BF%D0%B8%D1%81%D1%8B%D0%B2%D0%B0%D0%B5%D1%82-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D1%83-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%BE%D0%B9-%D1%83%D0%B4%D0%BE%D0%B1%D0%BD%D0%BE%D0%B9-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%BD%D0%BE%D0%B9-%D0%B0-%D1%87%D0%B0%D1%81%D1%82%D0%B8-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%BC%D0%B8\" aria-label=\"the clean architecture описывает основные общие правила построения архитектуры приложения как сделать разработку тестируемой удобной понятной а части системы взаимозаменяемыми permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Clean Architecture описывает основные общие правила построения архитектуры приложения. Как сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми.</h4>\n<hr>\n<p><em>Перевод статьи <a href=\"https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html\">The Clean Architecture</a> от <a href=\"https://blog.cleancoder.com/\">Robert Martin</a> 13 августа 2012.</em></p>\n<p><img src=\"/media/2018-08-15-the-clean-architecture/01.jpg\" alt=\"The Clean Architecture\" title=\"The Clean Architecture\"></p>\n<p>За последние несколько лет было предложено множество идей построения архитектуры.</p>\n<p>Например:</p>\n<ul>\n<li><a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">Hexagonal Architecture</a> (или Ports and Adapters) от Alistair Cockburn адаптированная Steve Freeman и Nat Pryce в их замечательной книге <a href=\"http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627\">Growing Object Oriented Software</a></li>\n<li><a href=\"http://jeffreypalermo.com/blog/the-onion-architecture-part-1/\">Onion Architecture</a> от Jeffrey Palermo</li>\n<li><a href=\"https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html\">Screaming Architecture</a> из блога Robert Martin</li>\n<li><a href=\"http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/\">DCI</a> от James Coplien и Trygve Reenskaug.</li>\n<li><a href=\"http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350\">BCE</a> от Ivar Jacobson из его книги Object Oriented Software Engineering: A Use-Case Driven Approach</li>\n</ul>\n<p>Несмотря на то, что детали, предложенные в этих архитектурах сильно варьируются, все же, они очень похожи.</p>\n<p>Все они разбивают проблему на схожие задачи. Они все добиваются этого разделения разложением кода на слои. Каждая имеет как минимум один слой для бизнес логики и другой - для интерфейсов.</p>\n<p>Каждая из этих архитектур создает систему, которая:</p>\n<ol>\n<li>Независимость от фреймворка. Архитектура не должна зависеть от какого-либо фреймворка или библиотеки, релиазующей какую-либо фичу. Такой подход позволяет использовать фреймворки как инструмент, нежели, подгонять ваш код под возможности фреймворка.</li>\n<li>Тестируемость. Бизнес-логика должна быть тестируема без UI, баз данных, веб-сервисов и прочих сторонник элементов.</li>\n<li>Независимость от UI. Должна быть возможность легко изменить UI без затрагивания других частей системы. Веб интерфейс может быть заменен на консольный без изменения бизнес-логики.</li>\n<li>Независимость от Базы Данных. Должна быть возможность заменить Oracle ил SQL Server на Mongo, BigTable, CouchDB или что-либо еще. Бизнес-логика не зависит от Базы Данных</li>\n<li>Независимость от внешних сервисов. Бизнес-логика просто не знает о существовании чего-либо во внешнем мире.</li>\n</ol>\n<p>На диаграме представлена попытка изобразить общую концепцию представленных архитектур.</p>\n<h1 id=\"правило-зависимости-dependency-rule\" style=\"position:relative;\"><a href=\"#%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-dependency-rule\" aria-label=\"правило зависимости dependency rule permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ПРАВИЛО ЗАВИСИМОСТИ (DEPENDENCY RULE)</h1>\n<p>Каждый слой на диаграме представляет разный слой кода. В целом, чем глубже вы двигаетесь внутрь диаграмы, тем на более высокий уровень абстракции попадаете. Внешние слои это реализация, внутренние - правила.</p>\n<p>Основное правило, благодаря которому эта архитектура работает - Правило Зависимости. Правило звучит так: внешние слои знают о внутренних, но не наоборот. Ничего из внутреннего слоя не должно знать о существовании внешнего. В частности, имена, объявленные во внешних слоях не должны даже упоминаться во внутренних. Это касается функций, классов, переменных и любых других сущностей.</p>\n<p>Точно также, форматы данных, используемые во внешних слоях не должны быть использованы где-либо во внутренних слоях. Особенно, если эти данные сгенерированы фреймворком, используемым во внешних слоях. Мы не хотим никаким образом влиять на внутренние слои из внешних.</p>\n<h1 id=\"слои\" style=\"position:relative;\"><a href=\"#%D1%81%D0%BB%D0%BE%D0%B8\" aria-label=\"слои permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>СЛОИ</h1>\n<h2 id=\"entities\" style=\"position:relative;\"><a href=\"#entities\" aria-label=\"entities permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ENTITIES</h2>\n<p>Entities содержат бизнес-логику используемую во всем приложении. Entities может быть объектом с методами или может быть просто набором структур данных и функций. Не имеет значения, в каком виде представлена Entity, пока она может быть использована различными модулями проекта.</p>\n<p>Если вы разрабатываете одно небольшое приложение, то Entities являются бизнес-объектами этого приложения. Они содержат в себе основную высокоуровневую логику. При каких-либо внешних изменениях, Entities - последнее, чего могут коснуться эти изменения. Например, изменения навигации или настроек безопасности никак не должны повлиять на них. Ни одно изменение модуля приложения не должно затронуть Entities.</p>\n<h2 id=\"use-cases\" style=\"position:relative;\"><a href=\"#use-cases\" aria-label=\"use cases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>USE CASES</h2>\n<p>Код этого уровня содержит бизнес-правила конкретного приложения. Он содержит и реализовывает все возможные варианты использования системы. Use cases отвечают за поток данных в/из Entities и используют Entities для выполнения необходимых действий.</p>\n<p>Изменения этого слоя не должны влиять на Entities. Также, изменения внених слоев, таких как, Базы Данных, никак не должны влиять на Use Cases.</p>\n<p>Однако, код Use Cases будет изменен при изменении логики работы приложения. Если изменится какой-либо случай использования приложения, эти изменения будут реализованы в этом слое.</p>\n<h2 id=\"interface-adapters\" style=\"position:relative;\"><a href=\"#interface-adapters\" aria-label=\"interface adapters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTERFACE ADAPTERS</h2>\n<p>Этот слой представляет из себя набор адаптеров, которые конвертируют данные, из формата, который удобен для использования в Entities и Use Cases в формат, более удобный для внешних сервисов, таких как Базы Данных или Web-сервисы. Например, в этом слое должен содержаться полностью весь GUI MVC. Контроллеры, Презентеры, Представления, все находится здесь. Модели, пожалуй, это всего лишь структуры данных, которые передаются из Контролеров в Use Cases и обратно из Use Cases в Представления и Презентеры.</p>\n<p>По аналогии, в этом слое данные должны быть конвертированы из формата, удобного для использования в Entities и Use Cases в форматы, удобные для хранения, например в Базах Данных. Код изнутри этого слоя не должен что-либо знать о Базах Данных. Если используется SQL база данных, то все SQL запросы должны быть обработаны именно на уровне этого слоя.</p>\n<p>Также, в этом слое должны находиться все другие возможные адаптеры, конвертирующие данные в формат удобный для использования в любых других внешних сервисах и наоборот в форматы, используемые в Entities и Use Cases.</p>\n<h2 id=\"frameworks-and-drivers\" style=\"position:relative;\"><a href=\"#frameworks-and-drivers\" aria-label=\"frameworks and drivers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FRAMEWORKS AND DRIVERS</h2>\n<p>Самый дальний, внешний слой, состоящий из фреймворков и различных инструментов, таких как Базы Данных, Web-сервисы. В общем, вы не должны писать здесь много кода, кроме связующего кода с внутренними слоями.</p>\n<p>На этом слое реализованы все детали. Связь с Web-сервисами - это детали. Базы Данных - это детали. Мы оставили все это снаружи, чтобы не причинять вреда внутренним слоям.</p>\n<h1 id=\"и-это-все\" style=\"position:relative;\"><a href=\"#%D0%B8-%D1%8D%D1%82%D0%BE-%D0%B2%D1%81%D0%B5\" aria-label=\"и это все permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>И ЭТО ВСЕ?</h1>\n<p>Нет. Эти слои - схематичны. Вероятно, вам понадобится что-либо, не вписывающие в эти четыре слоя. Нет такого правила, которое говорит, что вы должны использовать только эти четыре слоя. Однако, Правило Зависимостей (Dependency Rule) должно выполняться всегда. Исходный код на любом слое должны ссылаться на внутренний. При движение вовнутрь, уровень абстракции увеличивается. Внешний слой - низкоуровневая реализация деталей. Чем дальше вы продвигаетесь вовнутрь, тем более абстрактным становится код и более высокоуровневую логику реализовывает. Самый внутренний слой отвечает за общую логику.</p>\n<h1 id=\"пересечение-границ-слоев\" style=\"position:relative;\"><a href=\"#%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%86-%D1%81%D0%BB%D0%BE%D0%B5%D0%B2\" aria-label=\"пересечение границ слоев permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ПЕРЕСЕЧЕНИЕ ГРАНИЦ СЛОЕВ</h1>\n<p>На диаграмме справа-снизу представлено, как можно пересечь границы слоя. Там показано, как Контроллеры и Представления общаются с Use Cases. Обратите внимание на поток управления. Он начинается в Контроллере, проходит через Use Case и заканчивается в Презентере. Также обратите внимание на зависимости исходного кода. Каждый из них указывает на Use Case.</p>\n<p>Обычно мы решает это противоречие при помощи <a href=\"https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B8%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9\">Принципа Инверсии Зависимостей</a>. В таких языках, как Java, мы должны настроить интерфейсы и наследования, так, чтобы зависимости исходного кода были противоположны потоку управления в точках пересечения границ слоев.</p>\n<p>Допустим, Use Case должен обратиться к Презентеру. Это обращение не должно быть реализовано напрямую, чтобы не нарушать Правило Зависимостей (Dependency Rule): внутренние слои не должны знать о реализации внешних. В таком случае, Use Case обратится к интерфейсу (изображено на диаграмме как Use Case Output Port) внутреннего слоя, а Презентер из внешнего слоя должен его реализовать.</p>\n<p>Подобная техника используется для пересечения остальных границ архитектуры. Мы используем преумещества динамического полиморфизма, чтобы зависимости исходного кода были противоположны потоку управления. Таким образом мы не нарушаем правило зависимостей (Dependency Rule) вне зависимости от направления потока управления.</p>\n<h1 id=\"какие-данные-должны-пересекать-границы\" style=\"position:relative;\"><a href=\"#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D0%BA%D0%B0%D1%82%D1%8C-%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B\" aria-label=\"какие данные должны пересекать границы permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>КАКИЕ ДАННЫЕ ДОЛЖНЫ ПЕРЕСЕКАТЬ ГРАНИЦЫ</h1>\n<p>Обычно, данные, пересекаемые границы, являются обычными структурами данных. Вы можете пользоваться основными структурами или Data Transfer объектами. Или данные могут быть аргументами вызова функций. Или вообще можно представлять данные в виде hashmap или засунуть в объект. Важно, чтобы данные, пересекаемые границы, были простыми и изолированными. Мы же не хотим читерить и передавать Entities или строки из Базы Данных. Также передаваемые данные не должны иметь какие-либо зависимости и нарушать правило зависимостей (Dependency Rule).</p>\n<p>Например, множество фреймворков возвращает из Базы Данных данные в очень удобном формате. Назовем это RowStructure. Однако нельзя передавать RowStructure через границы слоев. Это нарушает правило зависимостей (Dependency Rule) потому что таким образом мы можем дать внутреннему слою информацию о реализации и структуре используемых данных внешнего.</p>\n<p>В общем, при передаче данных через границу, они должны быть представлены в формате, наиболее удобном для использования во внутреннем слое.</p>\n<h1 id=\"заключение\" style=\"position:relative;\"><a href=\"#%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5\" aria-label=\"заключение permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ЗАКЛЮЧЕНИЕ</h1>\n<p>Следовать этим простым правилам не так сложно, однако это сохранит вас от головной боли в будущем. Разделением кода на слои и следованием правилу зависимостей (Dependency Rule) можно создать систему, которая будет действительно тестируемой со всеми вытекающими из этого плюсами. Если какая-то внешняя часть системы устареет (например, База Данных или фреймворк), заменить его будет достаточно легко без каких-либо проблем.</p>\n<h1 id=\"интересные-ссылки\" style=\"position:relative;\"><a href=\"#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B5%D1%81%D0%BD%D1%8B%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8\" aria-label=\"интересные ссылки permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ИНТЕРЕСНЫЕ ССЫЛКИ</h1>\n<ul>\n<li><a href=\"https://habr.com/company/mobileup/blog/335382/\">Заблуждения Clean Architecture</a></li>\n<li><a href=\"https://habr.com/post/233747/\">Луковая архитектура</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=lZq8Jlq18Ec\">Часовое видео от Robert Martin о Clean Architecture на английском</a></li>\n</ul>","fields":{"slug":"/posts/the-clean-architecture","tagSlugs":["/tag/the clean architecture","/tag/ddd"],"categorySlug":"/category/development"},"frontmatter":{"date":"2018-08-15T21:40:00.000Z","description":"The Clean Architecture описывает основные общие правила построения архитектуры приложения. Как сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми.","category":"development","tags":["the clean architecture","ddd"],"title":"THE CLEAN ARCHITECTURE"}}},"pageContext":{"slug":"/posts/the-clean-architecture","allCategories":[{"fieldValue":"development","totalCount":3,"categoryColor":"pink-600"},{"fieldValue":"recipes","totalCount":6,"categoryColor":"green-600"}]}},"staticQueryHashes":["2052939023","251939775","401334301"]}